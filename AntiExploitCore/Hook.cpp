#include "Hook.h"
#include "capstone/capstone.h"

BOOL ChangeProtectionRWX (PVOID ptr)
{
	DWORD old = 0;
	if (!VirtualProtect(ptr, TRAMPOLINE_SIZE, PAGE_EXECUTE_READWRITE, &old))
		return FALSE;
	return TRUE;
}
BOOL SetPagePermisson(PVOID pvStub, DWORD dwNewProtect, DWORD* pdwOldProtect)
{
	DWORD old = 0;
	if (!VirtualProtect(pvStub, TRAMPOLINE_SIZE, dwNewProtect, pdwOldProtect ? pdwOldProtect : &old))
		return FALSE;
	return TRUE;
}
size_t InstructionBoundary(PVOID pv) // get nearest possible size of overwrited instruction (to not overwrite in the half of instruction)
{
	size_t bound = 0, needed = 5; // jmp near 32 
	PBYTE pb = (PBYTE)pv;

	for (; bound < needed; )
	{
		DWORD cbInstr = GetInstructionLength(pb + bound);
		if (!cbInstr)
		{
			bound = 0;
			break;
		}
		bound += cbInstr;
		
	}
	return bound;
}
LONG __stdcall HookTransactionBegin()
{
	// returns NO_ERROR or ERROR_INVALID_OPERATION
	threadHooks* threadPendingHooks = pendingHooks[GetCurrentThreadId()];

	if (!threadPendingHooks)
	{
		threadPendingHooks = new threadHooks();
		pendingHooks[GetCurrentThreadId()] = threadPendingHooks;
	}

	threadPendingHooks->clearHooks();

	if (!(threadPendingHooks = pendingRemoveHooks[GetCurrentThreadId()]))
	{
		threadPendingHooks = new threadHooks();
		pendingRemoveHooks[GetCurrentThreadId()] = threadPendingHooks;
	}

	threadPendingHooks->clearHooks();

	return NO_ERROR;
}

LONG __stdcall HookAttach (PVOID* originalFunc, PVOID hookedFunc)
{
	threadHooks * threadPendingHooks = pendingHooks[GetCurrentThreadId()];
	if (!threadPendingHooks)
	{
		return ERROR_INVALID_OPERATION; // DetourTransactionBegin not called before
	}
	if (!*originalFunc)
	{
		return ERROR_INVALID_HANDLE;   // can't read original func first bytes
	}

	threadHooks::hookData threadHookData{};

	threadHookData.ppfnOriginalFunction = originalFunc;
	threadHookData.pfnToDetour = *originalFunc;
	threadHookData.pfnDetourTarget = hookedFunc;

	threadPendingHooks->hooks.push_back(threadHookData);

	return NO_ERROR;
}
LONG __stdcall HookDetach(PVOID* originalFunc, PVOID hookedFunc)
{
	threadHooks* threadPendingHooksRemove = pendingRemoveHooks [GetCurrentThreadId()];
	if (!threadPendingHooksRemove)
	{
		return ERROR_INVALID_OPERATION;
	}
	if (!*originalFunc)
		return ERROR_INVALID_HANDLE;

	threadHooks::hookData threadHookData{};

	threadHookData.ppfnOriginalFunction = originalFunc;
	threadHookData.pfnToDetour = *originalFunc;
	threadHookData.pfnDetourTarget = hookedFunc;

	threadPendingHooksRemove->hooks.push_back(threadHookData);

	return NO_ERROR;
}

void InitHookStub()
{
	if (hookStubPtr)
	{
		return;
	}

	LARGE_INTEGER li = { 0, 0 };

	QueryPerformanceCounter(&li);
	srand(GetTickCount() ^ li.LowPart ^ li.HighPart);

	hookStubPtr = (PVOID)VirtualAlloc(NULL, HOOK_TRAMPOLINE_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
}
void ReleaseStub(PVOID pvStub)
{
	size_t offs = ((PBYTE)pvStub - (PBYTE)hookStubPtr) / TRAMPOLINE_SIZE;

	// !!fix this later!!
	// ZeroMemory(pvStub, STUB_SIZE);

	setStubOffsTaken.erase(offs);
}

LONG __stdcall HookTransactionCommit()
{
	// try to hook all funcs, if one function or more hooks inject fails then return error

	BOOL hooksToAdd = FALSE;
	LONG fail = NO_ERROR;

	threadHooks* threadPendingHooks = pendingHooks[GetCurrentThreadId()];
	if (!threadPendingHooks)
		return ERROR_INVALID_OPERATION;  // HookTransactionBegin not called before

	if (threadPendingHooks->hooks.size() == 0)
	{
		threadPendingHooks = pendingHooks[GetCurrentThreadId()];
		if (!threadPendingHooks)
		{
			return ERROR_INVALID_OPERATION;  // no functions are hooked
		}
	}
	else
	{
		hooksToAdd = TRUE; 
	}

	InitHookStub(); // if not initialized before

	if (hooksToAdd)
	{
		if (threadPendingHooks->hooks.size() != 0)
		{
			SuspendThreads();

			for (threadHooks::hookData const &it : threadPendingHooks->hooks)
			{
				PVOID pvStub = GetFreeStub();
				if (!pvStub)
				{
					ResumeThreads();
					return ERROR_NOT_ENOUGH_MEMORY;
				}

				if (!HookWrite(pvStub, it))
				{
					fail = ERROR_INVALID_BLOCK;
				}
			}
			ResumeThreads();
		}
	}

	threadHooks* threadPendingHooksRemove = pendingRemoveHooks[GetCurrentThreadId()];
	if (!threadPendingHooksRemove)
		return ERROR_INVALID_OPERATION;

	if (threadPendingHooksRemove->hooks.size() != 0) 
	{
		SuspendThreads();

		for (threadHooks::hookData const &it : threadPendingHooksRemove->hooks)
		{
			if (!HookRemove(it))
			{
				fail = ERROR_INVALID_BLOCK;
			}
		}
		ResumeThreads();
	}
	return fail;
}
PVOID GetFreeStub()
{
	BOOL bValidSlot = FALSE;
	size_t offs = 0;

	for (size_t i = 0; i < 32; i++) // arbitrary number of times
	{
		offs = (size_t)(rand() % TRAMPOLINE_MAX_ENTRIES);

		if (setStubOffsTaken.find(offs) == setStubOffsTaken.end())
		{
			bValidSlot = TRUE;
			break;
		}
	}

	if (!bValidSlot)
	{
		for (size_t i = 0; i < TRAMPOLINE_MAX_ENTRIES; i++)
		{
			if (setStubOffsTaken.find(i) == setStubOffsTaken.end())
			{
				offs = i;
				bValidSlot = TRUE;

				break;
			}
		}
	}

	if (!bValidSlot)
	{
		// no free slots!
		return NULL;
	}

	setStubOffsTaken.insert(offs);

	return ((PBYTE)hookStubPtr + (offs * TRAMPOLINE_SIZE));
}
BOOL SuspendThreads()
{
	BOOL bSuccess = FALSE;

	HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE)
		return bSuccess;

	THREADENTRY32 te32 = { 0 };
	te32.dwSize = sizeof(THREADENTRY32);

	if (!Thread32First(hThreadSnap, &te32))
		return bSuccess;

	bSuccess = TRUE;
	do
	{
		if (te32.th32OwnerProcessID == GetCurrentProcessId())
		{
			if (te32.th32ThreadID != GetCurrentThreadId())
			{
				HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID);
				if (!hThread)
				{
					bSuccess = FALSE;
					continue;
				}

				if (SuspendThread(hThread) == (DWORD)-1)
				{
					bSuccess = FALSE;
				}

				CloseHandle(hThread);
			}
		}
	} 
	while (Thread32Next(hThreadSnap, &te32) != FALSE);

	return bSuccess;
}
BOOL ResumeThreads()
{
	BOOL bSuccess = FALSE;

	HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap == INVALID_HANDLE_VALUE)
		return bSuccess;

	THREADENTRY32 te32 = { 0 };
	te32.dwSize = sizeof(THREADENTRY32);

	if (!Thread32First(hThreadSnap, &te32))
		return bSuccess;

	bSuccess = TRUE;

	do
	{
		if (te32.th32OwnerProcessID == GetCurrentProcessId())
		{
			if (te32.th32ThreadID != GetCurrentThreadId())
			{
				HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID);
				if (!hThread)
				{
					bSuccess = FALSE;
					continue;
				}

				if (ResumeThread(hThread) == (DWORD)-1)
				{
					bSuccess = FALSE;
				}

				CloseHandle(hThread);
			}
		}
	} 
	while (Thread32Next(hThreadSnap, &te32) != FALSE);
	return bSuccess;
}
                                                                    
BOOL HookWrite (PVOID pvStub, threadHooks::hookData dt) // [FIRST BYTES FUNCTION][JMP FUNC]
{
	PBYTE pbStub = (PBYTE)pvStub;
	DWORD diff = 0;
	BOOL bJmpThunk = FALSE;

	*dt.ppfnOriginalFunction = pbStub;

	size_t bound = InstructionBoundary(dt.pfnToDetour);
	if (bound == 0)
		return FALSE;

	if (!SetPagePermisson(pbStub, PAGE_EXECUTE_READWRITE, NULL))
		return ERROR_NOT_ENOUGH_MEMORY;

	memcpy(pbStub, dt.pfnToDetour, bound); // copies first 5 bytes of original func to stub

	if (pbStub[0] == 0xe8 || pbStub[0] == 0xe9) // call/jmp rel-32
	{
		diff = *(DWORD*)(pbStub + 1);
		PBYTE pbOriginalFunc = (PBYTE)dt.pfnToDetour + diff + 5;
		*(DWORD*)(pbStub + 1) = (DWORD)pbOriginalFunc - (DWORD)pbStub - 5;
	}

	diff = (DWORD)((PBYTE)dt.pfnToDetour - 5 - pbStub);  // diff to jmp func on stub
	pbStub[bound] = 0xe9; // jmp near
	*(DWORD*)((PBYTE)pbStub + bound + 1) = diff;

	if (!SetPagePermisson(pvStub, PAGE_EXECUTE_READ, NULL))
		return ERROR_NOT_ENOUGH_MEMORY;

	DWORD dwOldProtect = 0;

	if (!SetPagePermisson(dt.pfnToDetour, PAGE_EXECUTE_READWRITE, &dwOldProtect))
		return ERROR_NOT_ENOUGH_MEMORY;

	diff = (DWORD)((PBYTE)dt.pfnDetourTarget - (PBYTE)dt.pfnToDetour - 5);   // diff to own func

	PBYTE pb = (PBYTE)dt.pfnToDetour;
	pb[0] = 0xe9;
	*(DWORD*)(pb + 1) = diff;

	if (!SetPagePermisson(dt.pfnToDetour, dwOldProtect, NULL))
		return ERROR_NOT_ENOUGH_MEMORY;

	return TRUE;
}

BOOL HookRemove (threadHooks::hookData dt)
{
	PBYTE pbStub = (PBYTE)*dt.ppfnOriginalFunction;
	PBYTE pbOriginalFunction = NULL;
	DWORD diff = 0;

	size_t bound = InstructionBoundary(pbStub);
	if (bound == 0)
		return FALSE;

	DWORD dwOldProtect = 0;

	if (pbStub[0] == 0xe8 || pbStub[0] == 0xe9) // call/jmp rel-32
	{
		diff = *(DWORD*)(pbStub + 1);
		pbOriginalFunction = (PBYTE)pbStub + diff + 5;

		diff = *(DWORD*)(pbStub + bound + 1);
		PBYTE pbThunk = pbStub + bound + diff;

		if (!SetPagePermisson(pbThunk, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			return FALSE;

		*(DWORD*)(pbThunk + 1) = (DWORD)(pbOriginalFunction - pbThunk - 5);

		if (!SetPagePermisson(pbThunk, dwOldProtect, NULL))
			return FALSE;

		pbOriginalFunction = pbThunk;
	}
	else
	{
		diff = *(DWORD*)(pbStub + bound + 1); // jmp
		pbOriginalFunction = pbStub + diff + 5;

		if (!SetPagePermisson(pbOriginalFunction, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			return FALSE;

		// write back stub code over jump near 32
		memcpy(pbOriginalFunction, pbStub, bound);

		if (!SetPagePermisson(pbOriginalFunction, dwOldProtect, NULL))
			return FALSE;
	}

	// restore user pointer to function
	*dt.ppfnOriginalFunction = pbOriginalFunction;

	// free stub
	ReleaseStub(pbStub);

	return TRUE;
}
ULONG GetInstructionLength(void* ptr)
{
	uint8_t codeBuffer[20]{};
	memcpy(codeBuffer, ptr, 20);

	csh handle;
	cs_open(CS_ARCH_X86, CS_MODE_32, &handle);
	cs_insn* insn;
	size_t count;
	count = cs_disasm(handle, codeBuffer, 20, 0, 0, &insn);
	if (count > 0)
	{
		return insn->size;
	}
	cs_free(insn, count);
	return 0;
}
FN_RTLDISPATCHEXCEPTION GetRtlDispatchException() // RtlDispatchException is not exported by ntdll.dll
{
	PBYTE searchAreaPtr = (PBYTE)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "KiUserExceptionDispatcher");
	if (!searchAreaPtr)
		return NULL;

	for (DWORD i = 0; i < 20; i++)
	{
		DWORD dwInstrLen = GetInstructionLength(searchAreaPtr);
		if (!dwInstrLen)
			return NULL;

		if (searchAreaPtr[0] == 0xe8 && dwInstrLen == 5) // call
		{
			return (FN_RTLDISPATCHEXCEPTION)(searchAreaPtr + 5 + *(DWORD*)(searchAreaPtr + 1));
		}
		searchAreaPtr += dwInstrLen;
	}
	return NULL;
}