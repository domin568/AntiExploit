#include "AntiExploitFunctionality.h"

#define ACCESS_VIOLATION_WRITE 1
#define DEP_VIOLATION 8

#pragma warning(disable : 5208)

#define GETRETNADDR(arg)	__asm\
	{\
		__asm push eax\
		__asm push ebx\
		\
		__asm lea eax, [arg]\
		__asm mov ebx, [ebp + 4]\
		__asm mov [eax], ebx\
		\
		__asm pop ebx\
		__asm pop eax\
	}

std::vector <MODULE_INFO> GetLoadedModules()
{
	std::vector <MODULE_INFO> ret{};
	LPMODULEENTRY32W lpme = new MODULEENTRY32W;
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
	if (!hSnapshot)
	{
		return ret;
	}
	lpme->dwSize = sizeof(MODULEENTRY32W);

	MODULE_INFO currentModule{};

	if (Module32First(hSnapshot, lpme))
	{
		currentModule.baseAddr = (HMODULE)lpme->modBaseAddr;
		currentModule.size = lpme->modBaseSize;
		ret.push_back(currentModule);
		while (Module32Next(hSnapshot, lpme))
		{
			currentModule.baseAddr = (HMODULE)lpme->modBaseAddr;
			currentModule.size = lpme->modBaseSize;
			ret.push_back(currentModule);
		}
	}
	CloseHandle(hSnapshot);
	delete lpme;
	return ret;
}
BOOL IsJmpOrCallEsp(LPVOID lpvAddress)
{
	BOOL bIsJmpEsp = FALSE;

	PBYTE pbAddress = (PBYTE)lpvAddress;
	if (!pbAddress)
		return bIsJmpEsp;

	struct 
	{
		BYTE Instr[2];
	} JmpEspEquivalents[4] = 
	{
		{0xff, 0xe4},  // jmp esp
		{0xff, 0xd4},  // call esp 
		{0x54, 0xc3},  // push esp/retn
		{0x54, 0xc2}   // push esp/ret
	};

	for (DWORD i = 0; i < 4; i++)
	{
		if (pbAddress[0] == JmpEspEquivalents[i].Instr[0] && pbAddress[1] == JmpEspEquivalents[i].Instr[1])
		{
			bIsJmpEsp = TRUE;
			return bIsJmpEsp;
		}
	}
	return bIsJmpEsp;
}
BOOL IsAddrInLoadedModules(LPVOID addr)
{
	for (MODULE_INFO mod : currentLoadedModules)
	{
		if (addr >= mod.baseAddr && addr <= mod.baseAddr + mod.size)
		{
			return true;
		}
	}
	return false;
}
BOOL IsMemMappedOrModule(LPVOID addr)
{
	MEMORY_BASIC_INFORMATION mbi = { 0 };

	if (VirtualQuery(addr, &mbi, sizeof(mbi)))
	{
		if (mbi.State & MEM_COMMIT)
		{
			if ((mbi.Type & MEM_IMAGE) || (mbi.Type & MEM_MAPPED))
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}
BOOL IsBadPtr(LPVOID lpvPtr, DWORD cbPtr)
{
	BOOL bSuccess = TRUE;
	BYTE rgTemp[32];
	SIZE_T cbRead = 0;
	PBYTE pbPtr = (PBYTE)lpvPtr;

	for (SIZE_T i = 0; i < cbPtr;)
	{
		SIZE_T dwReadLength = (cbPtr - i) < 32 ? (cbPtr - i) : 32;

		if (!ReadProcessMemory(GetCurrentProcess(), pbPtr + i, rgTemp, dwReadLength, &cbRead))
		{
			return bSuccess;
		}
		i += cbRead;
	}

	bSuccess = FALSE;
	return bSuccess;
}
BOOL GetSEHHandlerAndNext(DWORD dwNthEntry, LPVOID* plpvHandler, LPVOID* plpvPrev)
{
	BOOL bFoundEntry = FALSE;
	PEXCEPTION_REGISTRATION pSehChain = NULL;

	__asm
	{
		push eax
		mov eax, dword ptr fs : [0]
		mov pSehChain, eax
		pop eax
	}

	for (DWORD i = 0; i < dwNthEntry; i++)
	{
		if (IsBadPtr(pSehChain, sizeof(EXCEPTION_REGISTRATION)))
		{
			FatalAppExitW(0, L"Błąd w łańcuchu SEH, aplikacja znajduje się w nieokreślonym stanie i zostanie zamknięta");
		}
		pSehChain = pSehChain->Prev;
	}

	if (pSehChain && pSehChain != (PEXCEPTION_REGISTRATION)0xffffffff)
	{
		if (IsBadPtr(pSehChain, sizeof(EXCEPTION_REGISTRATION)))
		{
			FatalAppExitW(0, L"Błąd w łańcuchu SEH, aplikacja znajduje się w nieokreślonym stanie i zostanie zamknięta");
		}

		*plpvHandler = pSehChain->Handler;
		*plpvPrev = pSehChain->Prev;

		bFoundEntry = TRUE;
	}
	return bFoundEntry;
}
BOOL IsSEHExploit(LPVOID SEHHandler)
{
#define ISPOP(ptr)			((ptr[0] - 0x58) >= 0 && (ptr[0] - 0x58) <= 8)
#define ISADDESPBYTE(ptr)		(ptr[0] == 0x83 && ptr[1] == 0xC4)
#define ISADDESPDWORD(ptr)		(ptr[0] == 0x81 && ptr[1] == 0xC4)
#define ISSUBESPDWORD(ptr)		(ptr[0] == 0x81 && ptr[1] == 0xEC)
#define ISSUBESPBYTE(ptr)		(ptr[0] == 0x83 && ptr[1] == 0xEC)
#define ISRET(ptr)			(ptr[0] == 0xC2 || ptr[0] == 0xC3)

	if (IsBadPtr(SEHHandler,30))
	{
		return false;
	}
	char insBuf[30];
	DWORD read{};

	if (ReadProcessMemory(GetCurrentProcess(), SEHHandler, insBuf, 30, &read))
	{
		if (ISPOP(insBuf) && ISRET((insBuf + 1)))
			return TRUE;
		if (ISPOP(insBuf) && ISPOP((insBuf + 1)) && ISRET((insBuf + 2)))
			return TRUE;
		if (ISPOP(insBuf) && ISPOP((insBuf + 1)) && ISPOP((insBuf + 2)) && ISRET((insBuf + 3)))
			return TRUE;
		if (ISPOP(insBuf) && ISPOP((insBuf + 1)) && ISPOP((insBuf + 2)) && ISPOP((insBuf + 3)) && ISRET((insBuf + 4)))
			return TRUE;
		if (ISPOP(insBuf) && ISPOP((insBuf + 1)) && ISPOP((insBuf + 2)) && ISPOP((insBuf + 3)) && ISPOP((insBuf + 4)) && ISRET((insBuf + 5)))
			return TRUE;
		if (ISSUBESPBYTE(insBuf) && ISRET((insBuf + 3)))
			return TRUE;
		if (ISSUBESPDWORD(insBuf) && ISRET((insBuf + 6)))
			return TRUE;
		if (ISADDESPBYTE(insBuf) && ISRET((insBuf + 3)))
			return TRUE;
		if (ISADDESPDWORD(insBuf) && ISRET((insBuf + 6)))
			return TRUE;
	}
	return FALSE;
}

BOOLEAN __stdcall My_RtlDispatchException(
	__in PEXCEPTION_RECORD  ExceptionRecord,
	__in PCONTEXT           Context
)
{
	// check fault is not STATUS_ACCESS_VIOLATION and faulting address is not a stack base

	if (ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)
	{
		LPVOID addrFault = (LPVOID)ExceptionRecord->ExceptionInformation[1];

		if (ExceptionRecord->ExceptionInformation[0] == ACCESS_VIOLATION_WRITE) // thread attempted to write to inaccessible memory
		{
			HANDLE stackBase;
			HANDLE stackTop;
			if (GetStackRegionThread(GetCurrentThread(), &stackBase, &stackTop))
			{
				//ULONG stackSize = (ULONG)stackBase - (ULONG)stackTop;
				
				if (addrFault == stackBase) // all stack has been overwritten with data, SEH handler were overwritten too
				{
					FatalAppExitW(0, L"Wykryto próbę nadpisania ramki SEH, aplikacja zostanie zamknięta");
				}
			}
		}
		else if (ExceptionRecord->ExceptionInformation[0] == DEP_VIOLATION)
		{
			FatalAppExitW(0, L"Wykryto próbę wykonania kodu na stronie danych (DEP violation), aplikacja zostanie zamknięta");
		}
	}

	CRITICAL_SECTION SEHCheck;

	EnterCriticalSection(&SEHCheck);
	// do not let other threads load more modules, that would lead to inconsistent app state
	currentLoadedModules = GetLoadedModules();

	LPVOID SEHHandler = NULL, nextHandler = NULL;


	// check if exception handler is in module addr (not in heap/stack)
	for (DWORD i = 0; GetSEHHandlerAndNext(i, &SEHHandler, &nextHandler); i++)
	{
		if (!IsAddrInLoadedModules(SEHHandler))
		{
			FatalAppExitW(0, L"Procedura obsługi wyjątku SEH wskazuje na miejsce poza załadowanymi modułami aplikacji, aplikacja zostanie zamknięta");
		}
	}
	
	// checks whether exception handler points to POP/POP/RET, SUB ESP, BYTE, SUB ESP, DWORD, ADD ESP, BYTE, ADD ESP, DWORD
	// most popular ROP gadgets

	if (IsSEHExploit(SEHHandler))
	{
		FatalAppExitW(0, L"Procedura obsługi wyjątku SEH wskazuje na ROP Gadget typu (pop reg, ret, oraz inne warianty), aplikacja zostanie zamknięta");
	}

	LeaveCriticalSection(&SEHCheck);
	
	return Original_RtlDispatchException(ExceptionRecord, Context);
}
HMODULE __stdcall My_LoadLibraryA(
	__in	char* lpFileName
)
{
	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja LoadLibraryA została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	hm = Original_LoadLibraryExA(lpFileName, NULL, 0);
	return hm;
}
HMODULE __stdcall My_LoadLibraryW(
	__in	LPWSTR lpFileName
)
{
	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja LoadLibraryW została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	hm = Original_LoadLibraryExW(lpFileName, NULL, 0);
	return hm;
}
HMODULE __stdcall My_LoadLibraryExA(
	__in        char* lpFileName,
	__reserved  HANDLE hFile,
	__in        DWORD dwFlags
)
{
	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja LoadLibraryExA została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	hm = Original_LoadLibraryExA(lpFileName, hFile, dwFlags);
	return hm;
}
HMODULE __stdcall My_LoadLibraryExW(
	__in        LPWSTR lpFileName,
	__reserved  HANDLE hFile,
	__in        DWORD dwFlags
)
{
	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja LoadLibraryW została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	hm = Original_LoadLibraryExW(lpFileName, hFile, dwFlags);
	return hm;
}
LONG __stdcall My_LdrLoadDll(
	__in PWCHAR				PathToFile,
	__in ULONG				Flags,
	__in PUNICODE_STRING	ModuleFileName,
	__out PHANDLE			ModuleHandle
)
{
	currentLoadedModules = GetLoadedModules();
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja LdrLoadDll została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}
	HMODULE ret = 0;
	return Original_LdrLoadDll(PathToFile, Flags, ModuleFileName, ModuleHandle);
}
BOOL WINAPI My_FreeLibrary(
	__in  HMODULE hModule
)
{
	// TODO
	return Original_FreeLibrary(hModule);
}
VOID WINAPI My_FreeLibraryAndExitThread(
	__in  HMODULE hModule,
	__in  DWORD dwExitCode
)
{
	Original_FreeLibraryAndExitThread(hModule, dwExitCode);
}
DWORD WINAPI My_CreateProcessInternalA(
	__in HANDLE	hToken,
	__in_opt	char* lpApplicationName,
	__inout_opt	char* lpCommandLine,
	__in_opt	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	__in_opt	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	__in		BOOL bInheritHandles,
	__in		DWORD dwCreationFlags,
	__in_opt	LPVOID lpEnvironment,
	__in_opt	char* lpCurrentDirectory,
	__in		LPSTARTUPINFO lpStartupInfo,
	__out		LPPROCESS_INFORMATION lpProcessInformation,
	__in		PHANDLE hNewToken
)
{
	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;
	DWORD dwRetnAddress = 0; // to asm inline

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja CreateProcessInternalA została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_CreateProcessInternalA(
			hToken,
			lpApplicationName,
			lpCommandLine,
			lpProcessAttributes,
			lpThreadAttributes,
			bInheritHandles,
			dwCreationFlags,
			lpEnvironment,
			lpCurrentDirectory,
			lpStartupInfo,
			lpProcessInformation,
			hNewToken
		);
}
DWORD WINAPI My_CreateProcessInternalW(
	__in HANDLE	hToken,
	__in_opt	LPWSTR lpApplicationName,
	__inout_opt	LPWSTR lpCommandLine,
	__in_opt	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	__in_opt	LPSECURITY_ATTRIBUTES lpThreadAttributes,

	__in		BOOL bInheritHandles,
	__in		DWORD dwCreationFlags,
	__in_opt	LPVOID lpEnvironment,
	__in_opt	LPWSTR lpCurrentDirectory,
	__in		LPSTARTUPINFO lpStartupInfo,
	__out		LPPROCESS_INFORMATION lpProcessInformation,
	__in		PHANDLE hNewToken
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja CreateProcessInternalW została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}	
	}

	return Original_CreateProcessInternalW(
		hToken,
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		lpProcessInformation,
		hNewToken);
}
BOOL WINAPI My_CreateProcessA(
	__in_opt     char* lpApplicationName,
	__inout_opt  char* lpCommandLine,
	__in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
	__in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
	__in         BOOL bInheritHandles,
	__in         DWORD dwCreationFlags,
	__in_opt     LPVOID lpEnvironment,
	__in_opt     char* lpCurrentDirectory,
	__in         LPSTARTUPINFO lpStartupInfo,
	__out        LPPROCESS_INFORMATION lpProcessInformation
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja CreateProcessA została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_CreateProcessA(
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		lpProcessInformation
	);
}
BOOL WINAPI My_CreateProcessW(
	__in_opt     LPWSTR lpApplicationName,
	__inout_opt  LPWSTR lpCommandLine,
	__in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
	__in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
	__in         BOOL bInheritHandles,
	__in         DWORD dwCreationFlags,
	__in_opt     LPVOID lpEnvironment,
	__in_opt     LPWSTR lpCurrentDirectory,
	__in         LPSTARTUPINFO lpStartupInfo,
	__out        LPPROCESS_INFORMATION lpProcessInformation
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja CreateProcessW została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_CreateProcessW(
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		lpProcessInformation
	);
}
FARPROC WINAPI My_GetProcAddress(
	__in	HMODULE hModule,
	__in	LPCSTR lpProcName
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja GetProcAddress została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_GetProcAddress(hModule, lpProcName);
}

HMODULE WINAPI My_GetModuleHandleA(
	__in_opt	char* lpModuleName
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja GetModuleHandleA została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_GetModuleHandleA(lpModuleName);
}
HMODULE WINAPI My_GetModuleHandleW(
	__in_opt	LPWSTR lpModuleName
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress))
		{
			FatalAppExitW(0, L"Funkcja GetModuleHandleW została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
		}
	}

	return Original_GetModuleHandleW(lpModuleName);
}
BOOL WINAPI My_VirtualProtect(
	__in	LPVOID lpAddress,
	__in	SIZE_T dwSize,
	__in	DWORD flNewProtect,
	__out	PDWORD lpflOldProtect
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja VirtualProtect została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji VirtualProtect wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

	return Original_VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}
BOOL WINAPI My_VirtualProtectEx(
	__in	HANDLE hProcess,
	__in	LPVOID lpAddress,
	__in	SIZE_T dwSize,
	__in	DWORD flNewProtect,
	__out	PDWORD lpflOldProtect
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja VirtualProtectEx została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji VirtualProtect wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

	return Original_VirtualProtectEx(hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
}
LONG NTAPI My_NtProtectVirtualMemory(
	__in HANDLE	ProcessHandle,
	__inout PVOID* BaseAddress,
	__inout PULONG	NumberOfBytesToProtect,
	__in ULONG		NewAccessProtection,
	__out PULONG	OldAccessProtection
)
{
	// TODO
	return Original_NtProtectVirtualMemory(ProcessHandle, BaseAddress, NumberOfBytesToProtect, NewAccessProtection, OldAccessProtection);
}
LPVOID WINAPI My_VirtualAlloc(
	__in_opt	LPVOID lpAddress,
	__in		SIZE_T dwSize,
	__in		DWORD flAllocationType,
	__in		DWORD flProtect
)
{
	// VirtualAlloc with size = 0x1 behaves like VirtualProtect 
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja VirtualAlloc została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji VirtualAlloc wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

	return Original_VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}
LPVOID WINAPI My_VirtualAllocEx(
	__in		HANDLE hProcess,
	__in_opt	LPVOID lpAddress,
	__in		SIZE_T dwSize,
	__in		DWORD flAllocationType,
	__in		DWORD flProtect
)
{
	// VirtualAlloc with size = 0x1 behaves like VirtualProtect 
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;


	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja VirtualAllocEx została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji VirtualAllocEx wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

	return Original_VirtualAllocEx(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
}
LONG NTAPI My_NtAllocateVirtualMemory(
	__in HANDLE		ProcessHandle,
	__inout PVOID* BaseAddress,
	__in ULONG		ZeroBits,
	__inout PULONG	RegionSize,
	__in ULONG		AllocationType,
	__in ULONG		Protect
)
{
	// TODO
	return Original_NtAllocateVirtualMemory(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
}
BOOL WINAPI My_SetProcessDEPPolicy(
	__in DWORD dwFlags
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja SetProcessDEPPolicy została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji SetProcessDEPPolicy wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

	if (dwFlags == 0) // probably ROP bypass attempt
	{
		SetLastError(ERROR_NOT_SUPPORTED);
		return FALSE;
	}
	return Original_SetProcessDEPPolicy(dwFlags);
}
LONG NTAPI My_NtSetInformationProcess(
	__in HANDLE ProcessHandle,
	__in PROCESS_INFORMATION_CLASS ProcessInformationClass,
	__in PVOID ProcessInformation,
	__in ULONG ProcessInformationLength
)
{
	DWORD dwRetnAddress = 0;
	GETRETNADDR(dwRetnAddress);

	currentLoadedModules = GetLoadedModules();
	HMODULE hm = NULL;

	GETRETNADDR(dwRetnAddress);
	if (!(IsMemMappedOrModule((LPVOID)dwRetnAddress)))
	{
		FatalAppExitW(0, L"Funkcja NtSetInformationProcess została wywołana z niezaufanego miejsca w pamięci, aplikacja zostanie zamknięta");
	}
	if (IsJmpOrCallEsp((LPVOID)dwRetnAddress))
	{
		FatalAppExitW(0, L"Wykryto exploit wykorzystujący technikę ROP. Powrót z funkcji NtSetInformationProcess wskazuje na kod, który skacze na stos, aplikacja zostanie zakmnięta");
	}

#define ProcessExecuteFlags				0x22
#define MEM_EXECUTE_OPTION_ENABLE		2

	if (ProcessInformationClass == ProcessExecuteFlags)
	{
		DWORD* pdwExecuteOption = (DWORD*)ProcessInformation;

		if (pdwExecuteOption && (*pdwExecuteOption & MEM_EXECUTE_OPTION_ENABLE) != 0)
		{
			// an attempt to enable execution of NX memory
			return STATUS_ACCESS_DENIED;
		}
	}

	return Original_NtSetInformationProcess(
		ProcessHandle,
		ProcessInformationClass,
		ProcessInformation,
		ProcessInformationLength
	);
}
HANDLE WINAPI My_CreateThread(
	__in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes,
	__in       SIZE_T dwStackSize,
	__in       LPTHREAD_START_ROUTINE lpStartAddress,
	__in_opt   LPVOID lpParameter,
	__in       DWORD dwCreationFlags,
	__out_opt  LPDWORD lpThreadId
)
{
	DWORD dwRetnAddress = 0, dwThreadId = 0;
	GETRETNADDR(dwRetnAddress);

	if ( (!IsMemMappedOrModule((LPVOID)dwRetnAddress)) || (!IsMemMappedOrModule((LPVOID)lpStartAddress)))
	{
		if ( (!IsAddrInLoadedModules((LPVOID)dwRetnAddress)) || (!IsAddrInLoadedModules((LPVOID)lpStartAddress)))
		{
			FatalAppExitW(0, L"Funkcja CreateThread została wywołana z niezaufanego miejsca w pamięci bądź adres początkowy dla wątku wskazuje na niezaufane miejsce, aplikacja zostanie zamknięta");
		}
	}

	if (dwStackSize < 0x80000)
		dwStackSize = 0x80000;

	return Original_CreateThread(
		lpThreadAttributes,
		dwStackSize,
		lpStartAddress,
		lpParameter,
		dwCreationFlags,
		&dwThreadId
	);
}
HANDLE WINAPI My_CreateRemoteThread(
	__in   HANDLE hProcess,
	__in   LPSECURITY_ATTRIBUTES lpThreadAttributes,
	__in   SIZE_T dwStackSize,
	__in   LPTHREAD_START_ROUTINE lpStartAddress,
	__in   LPVOID lpParameter,
	__in   DWORD dwCreationFlags,
	__out  LPDWORD lpThreadId
)
{
#ifdef DEBUG_BUILD
	CLogger::Break();
#endif
	
	// TODO

	return Original_CreateRemoteThread(
		hProcess,
		lpThreadAttributes,
		dwStackSize,
		lpStartAddress,
		lpParameter,
		dwCreationFlags,
		lpThreadId
	);
}
LONG NTAPI My_NtCreateThread(
	__out PHANDLE			ThreadHandle,
	__in ACCESS_MASK		DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES	ObjectAttributes,
	__in HANDLE				ProcessHandle,
	__out PCLIENT_ID		ClientId,
	__in PCONTEXT			ThreadContext,
	__in PINITIAL_TEB		InitialTeb,
	__in BOOLEAN			CreateSuspended
)
{
	DWORD dwRetnAddress = 0;

	GETRETNADDR(dwRetnAddress);

	HMODULE hmNtdll = GetModuleHandle(L"ntdll.dll");
	PVOID pvRtlUserThreadStart = (PVOID)GetProcAddress(hmNtdll, "RtlUserThreadStart");

	if ((!IsMemMappedOrModule((LPVOID)dwRetnAddress) || !IsMemMappedOrModule((LPVOID)ThreadContext->Eip) ||
		(pvRtlUserThreadStart == (PVOID)ThreadContext->Eip && !IsMemMappedOrModule((LPVOID)ThreadContext->Eax)))
		)
	{
		currentLoadedModules = GetLoadedModules();

		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress) || !IsAddrInLoadedModules((LPVOID)ThreadContext->Eip) 
			|| (pvRtlUserThreadStart == (PVOID)ThreadContext->Eip && !IsAddrInLoadedModules((LPVOID)ThreadContext->Eax)))
		{
			FatalAppExitW(0, L"Wątek tworzony przez NtCreateThread jest niezaufany");
		}
	}

	return Original_NtCreateThread(
		ThreadHandle,
		DesiredAccess,
		ObjectAttributes,
		ProcessHandle,
		ClientId,
		ThreadContext,
		InitialTeb,
		CreateSuspended
	);
}
LONG NTAPI My_NtCreateThreadEx(
	__out PHANDLE hThread,
	__in ACCESS_MASK DesiredAccess,
	__in LPVOID ObjectAttributes,
	__in HANDLE ProcessHandle,
	__in LPTHREAD_START_ROUTINE lpStartAddress,
	__in LPVOID lpParameter,
	__in BOOL CreateSuspended,
	__in ULONG StackZeroBits,
	__in ULONG SizeOfStackCommit,
	__in ULONG SizeOfStackReserve,
	__out LPVOID lpBytesBuffer
)
{
	DWORD dwRetnAddress = 0;

	GETRETNADDR(dwRetnAddress);

	HMODULE hmNtdll = GetModuleHandle(L"ntdll.dll");
	PVOID pvRtlUserThreadStart = (PVOID)GetProcAddress(hmNtdll, "RtlUserThreadStart");

	if ((!IsMemMappedOrModule((LPVOID)dwRetnAddress) || !IsMemMappedOrModule((LPVOID)lpStartAddress)))
	{
		currentLoadedModules = GetLoadedModules();

		if (!IsAddrInLoadedModules((LPVOID)dwRetnAddress) || !IsAddrInLoadedModules((LPVOID)lpStartAddress))
		{
			FatalAppExitW(0, L"Wątek tworzony przez NtCreateThreadEx jest niezaufany");
		}
	}
	Original_NtCreateThreadEx(
		hThread,
		DesiredAccess,
		ObjectAttributes,
		ProcessHandle,
		lpStartAddress,
		lpParameter,
		CreateSuspended,
		StackZeroBits,
		SizeOfStackCommit,
		SizeOfStackReserve,
		lpBytesBuffer
	);
}
VOID WINAPI My_ExitProcess(
	__in  UINT uExitCode
)
{
	return Original_ExitProcess(uExitCode);
}
VOID WINAPI My_ExitThread(
	__in  DWORD dwExitCode
)
{
	return Original_ExitThread(dwExitCode);
}
LONG NTAPI My_NtTerminateThread(
	__in HANDLE               ThreadHandle,
	__in LONG             ExitStatus
)
{
	return Original_NtTerminateThread(ThreadHandle, ExitStatus);
}

BOOL InjectAntiExploit()
{
	LONG result{};
	HookTransactionBegin();
	Original_RtlDispatchException = GetRtlDispatchException();
	HookAttach((PVOID*)&Original_RtlDispatchException, My_RtlDispatchException);
	result = HookTransactionCommit();


	HookTransactionBegin();
	HookAttach((PVOID*)&Original_LoadLibraryA, My_LoadLibraryA);
	HookAttach((PVOID*)&Original_LoadLibraryW, My_LoadLibraryW);
	HookAttach((PVOID*)&Original_LoadLibraryExA, My_LoadLibraryExA);
	HookAttach((PVOID*)&Original_LoadLibraryExW, My_LoadLibraryExW);
	HookAttach((PVOID*)&Original_FreeLibrary, My_FreeLibrary);
	HookAttach((PVOID*)&Original_FreeLibraryAndExitThread, My_FreeLibraryAndExitThread);
	HookAttach((PVOID*)&Original_LdrLoadDll, My_LdrLoadDll);
	HookAttach((PVOID*)&Original_CreateProcessA, My_CreateProcessA);
	HookAttach((PVOID*)&Original_CreateProcessW, My_CreateProcessW);
	HookAttach((PVOID*)&Original_CreateProcessInternalA, My_CreateProcessInternalA);
	HookAttach((PVOID*)&Original_CreateProcessInternalW, My_CreateProcessInternalW);
	HookAttach((PVOID*)&Original_GetProcAddress, My_GetProcAddress);
	HookAttach((PVOID*)&Original_GetModuleHandleA, My_GetModuleHandleA);
	HookAttach((PVOID*)&Original_GetModuleHandleW, My_GetModuleHandleW);
	HookAttach((PVOID*)&Original_VirtualProtect, My_VirtualProtect);
	HookAttach((PVOID*)&Original_VirtualProtectEx, My_VirtualProtectEx);
	HookAttach((PVOID*)&Original_NtProtectVirtualMemory, My_NtProtectVirtualMemory);
	HookAttach((PVOID*)&Original_VirtualAlloc, My_VirtualAlloc);
	HookAttach((PVOID*)&Original_VirtualAllocEx, My_VirtualAllocEx);
	HookAttach((PVOID*)&Original_NtAllocateVirtualMemory, My_NtAllocateVirtualMemory);
	HookAttach((PVOID*)&Original_SetProcessDEPPolicy, My_SetProcessDEPPolicy);
	HookAttach((PVOID*)&Original_NtSetInformationProcess, My_NtSetInformationProcess);
	HookAttach((PVOID*)&Original_CreateThread, My_CreateThread);
	HookAttach((PVOID*)&Original_NtCreateThread, My_NtCreateThread);
	HookAttach((PVOID*)&Original_NtCreateThreadEx, My_NtCreateThreadEx);
	HookAttach((PVOID*)&Original_ExitProcess, My_ExitProcess);
	HookAttach((PVOID*)&Original_NtTerminateThread, My_NtTerminateThread);
	result = HookTransactionCommit();

	if (result == NO_ERROR)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
BOOL DisableAntiExploit()
{
	HookTransactionBegin();
	HookDetach((PVOID*)&Original_RtlDispatchException, My_RtlDispatchException);
	HookDetach((PVOID*)&Original_LoadLibraryA, My_LoadLibraryA);
	HookDetach((PVOID*)&Original_LoadLibraryW, My_LoadLibraryW);
	HookDetach((PVOID*)&Original_LoadLibraryExA, My_LoadLibraryExA);
	HookDetach((PVOID*)&Original_LoadLibraryExW, My_LoadLibraryExW);
	HookDetach((PVOID*)&Original_LdrLoadDll, My_LdrLoadDll);
	HookDetach((PVOID*)&Original_FreeLibrary, My_FreeLibrary);
	HookDetach((PVOID*)&Original_FreeLibraryAndExitThread, My_FreeLibraryAndExitThread);
	HookDetach((PVOID*)&Original_CreateProcessA, My_CreateProcessA);
	HookDetach((PVOID*)&Original_CreateProcessW, My_CreateProcessW);
	HookDetach((PVOID*)&Original_CreateProcessInternalA, My_CreateProcessInternalA);
	HookDetach((PVOID*)&Original_CreateProcessInternalW, My_CreateProcessInternalW);
	HookDetach((PVOID*)&Original_GetProcAddress, My_GetProcAddress);
	HookDetach((PVOID*)&Original_GetModuleHandleA, My_GetModuleHandleA);
	HookDetach((PVOID*)&Original_GetModuleHandleW, My_GetModuleHandleW);
	HookDetach((PVOID*)&Original_VirtualProtect, My_VirtualProtect);
	HookDetach((PVOID*)&Original_VirtualProtectEx, My_VirtualProtectEx);
	HookDetach((PVOID*)&Original_NtProtectVirtualMemory, My_NtProtectVirtualMemory);
	HookDetach((PVOID*)&Original_VirtualAlloc, My_VirtualAlloc);
	HookDetach((PVOID*)&Original_VirtualAllocEx, My_VirtualAllocEx);
	HookDetach((PVOID*)&Original_NtAllocateVirtualMemory, My_NtAllocateVirtualMemory);
	HookDetach((PVOID*)&Original_VirtualAlloc, My_VirtualAlloc);
	HookDetach((PVOID*)&Original_VirtualAllocEx, My_VirtualAllocEx);
	HookDetach((PVOID*)&Original_NtAllocateVirtualMemory, My_NtAllocateVirtualMemory);
	HookDetach((PVOID*)&Original_SetProcessDEPPolicy, My_SetProcessDEPPolicy);
	HookDetach((PVOID*)&Original_NtSetInformationProcess, My_NtSetInformationProcess);
	HookDetach((PVOID*)&Original_CreateThread, My_CreateThread);
	HookDetach((PVOID*)&Original_NtCreateThread, My_NtCreateThread);
	HookDetach((PVOID*)&Original_NtCreateThreadEx, My_NtCreateThreadEx);
	HookDetach((PVOID*)&Original_ExitProcess, My_ExitProcess);
	HookDetach((PVOID*)&Original_NtTerminateThread, My_NtTerminateThread);
	HookDetach((PVOID*)&Original_RtlDispatchException, My_RtlDispatchException);
	LONG result = HookTransactionCommit();
	if (result == NO_ERROR)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

