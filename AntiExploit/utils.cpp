#include "utils.h"
#include "structs.h"

#define ProcessImageInformation 0x25
#define ProcessExecuteFlags 0x22
#define MEM_EXECUTE_OPTION_DISABLE 0x1
#define MEM_EXECUTE_OPTION_ENABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8

typedef LONG(NTAPI* pfnNtQueryInformationProcess)(
    IN  HANDLE ProcessHandle,
    IN  PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN  ULONG ProcessInformationLength,
    OUT PULONG ReturnLength    OPTIONAL
    );

pfnNtQueryInformationProcess gNtQueryInformationProcess;

HMODULE sm_LoadNTDLLFunctions()
{
    HMODULE hNtDll = LoadLibrary(_T("ntdll.dll"));
    if (hNtDll == NULL) return NULL;

    gNtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(hNtDll,
        "NtQueryInformationProcess");
    if (gNtQueryInformationProcess == NULL) 
    {
        FreeLibrary(hNtDll);
        return NULL;
    }
    return hNtDll;
}

ULONG CheckASLR(ULONG dwProcessId, ULONG& bASLR)
{
    if (HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessId))
    {
        sm_LoadNTDLLFunctions();
        SECTION_IMAGE_INFORMATION sii;
        LONG status = gNtQueryInformationProcess(hProcess, (PROCESSINFOCLASS)ProcessImageInformation, &sii, sizeof(sii), 0);

        CloseHandle(hProcess);

        if (0 <= status)
        {
            bASLR = sii.ImageDynamicallyRelocated;
        }
        return status;
    }
    return STATUS_ACCESS_DENIED;
}
ULONG CheckDEP(ULONG dwProcessId, ULONG & depStatus)
{
    if (HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, dwProcessId))
    {
        ULONG executeFlags;
        sm_LoadNTDLLFunctions();
        
        LONG status = gNtQueryInformationProcess(hProcess, (PROCESSINFOCLASS) ProcessExecuteFlags, &executeFlags, sizeof(ULONG), NULL);

        if (executeFlags & MEM_EXECUTE_OPTION_ENABLE)
        {
            depStatus = 0;
        }
        else
        {
            depStatus = 1;
        }
        if (executeFlags & MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION)
        {
            depStatus |= 2;
        }
        if (executeFlags & MEM_EXECUTE_OPTION_PERMANENT)
        {
            depStatus |= 4;
        }
        CloseHandle(hProcess);
        return NOERROR;
    }
    return STATUS_ACCESS_DENIED;
}
BOOL CheckLoadConfig(HANDLE hModule, BYTE * header, DWORD base, BOOLEAN& safeSEH, BOOLEAN& stackCanary)
{
    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)header;
    IMAGE_NT_HEADERS32* ntHeaders32 = (IMAGE_NT_HEADERS32*)(header + dos->e_lfanew);
    WORD machineType = ntHeaders32->FileHeader.Machine;
    WORD x64 = 0x8664; // little endian
    WORD x32 = 0x014c; // little endian
    safeSEH = true;
    stackCanary = true;

    if (machineType == x32)
    {
        IMAGE_DATA_DIRECTORY* dirs = (IMAGE_DATA_DIRECTORY*)(ntHeaders32->OptionalHeader.DataDirectory);
        if (ntHeaders32->OptionalHeader.NumberOfRvaAndSizes < 10)
        {
            safeSEH = false;
            stackCanary = false;
            return true;
        }
        DWORD rvaConfigDir = dirs[10].VirtualAddress;
        DWORD sizeConfigDir = dirs[10].Size;
        DWORD vaConfigDir = base + rvaConfigDir;
        BYTE* dataDirectoryBuf = new BYTE[sizeConfigDir];

        DWORD read{};
        IMAGE_LOAD_CONFIG_DIRECTORY32* loadConfig;

        if (ReadProcessMemory(hModule, (LPCVOID)vaConfigDir, dataDirectoryBuf, sizeConfigDir, &read))
        {
            loadConfig = (IMAGE_LOAD_CONFIG_DIRECTORY32*)dataDirectoryBuf;
        }
        else
        {
            delete[] dataDirectoryBuf;
            return false;
        }

        if (!loadConfig->SecurityCookie)
        {
            stackCanary = false;
        }
        if (rvaConfigDir == 0 && sizeConfigDir == 0)
        {
            safeSEH = false;
        }
        else if (read == sizeConfigDir)
        {
            if (!loadConfig->SEHandlerTable)
            {
                safeSEH = false;
            }
        }
        delete[] dataDirectoryBuf;
        return true;
    }
    else if (machineType == x64)
    {
        IMAGE_NT_HEADERS64* ntHeaders64 = (IMAGE_NT_HEADERS64*)(header + dos->e_lfanew);
        IMAGE_DATA_DIRECTORY* dirs = (IMAGE_DATA_DIRECTORY*)(header + (ULONG) ntHeaders64->OptionalHeader.DataDirectory);
        DWORD rvaConfigDir = dirs[10].VirtualAddress;
        DWORD sizeConfigDir = dirs[10].Size;
        DWORD vaConfigDir = base + rvaConfigDir;
        BYTE* dataDirectoryBuf = new BYTE[sizeConfigDir];

        DWORD read{};
        IMAGE_LOAD_CONFIG_DIRECTORY64* loadConfig;

        if (ReadProcessMemory(hModule, (LPCVOID)vaConfigDir, dataDirectoryBuf, sizeConfigDir, &read))
        {
            loadConfig = (IMAGE_LOAD_CONFIG_DIRECTORY64*)dataDirectoryBuf;
        }
        else
        {
            delete[] dataDirectoryBuf;
            return false;
        }

        if (!loadConfig->SecurityCookie)
        {
            stackCanary = false;
        }
        if (rvaConfigDir == 0 && sizeConfigDir == 0)
        {
            safeSEH = false;
        }
        else if (read == sizeConfigDir)
        {
            if (!loadConfig->SEHandlerTable)
            {
                safeSEH = false;
            }
        }
        delete[] dataDirectoryBuf;
        return true;
    }
    return false;
}
BOOL CheckSafeSEHStackCanary(ULONG dwProcessId, ULONG& safeSEHMissing, ULONG& safeSEHUnknown, ULONG& stackCookieMissing, ULONG& stackCookieUnknown, ULONG& nModules)
{
    LPMODULEENTRY32W lpme = new MODULEENTRY32W;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if (!hSnapshot)
    {
        return false;
    }
    lpme->dwSize = sizeof(MODULEENTRY32W);

    safeSEHMissing = 0;
    safeSEHUnknown = 0;
    stackCookieMissing = 0;
    stackCookieUnknown = 0;

    BYTE buf[0x1000]{};
    SIZE_T read {};

    if (Module32First(hSnapshot, lpme))
    {
        nModules = 1;
        BOOLEAN isSafeSEH = 0;
        BOOLEAN isStackCookie = 0;

        HANDLE hProc = OpenProcess(PROCESS_VM_READ, FALSE, dwProcessId);
        if (hProc)
        {
            if (ReadProcessMemory(hProc, lpme->modBaseAddr, buf, 0x1000, &read))
            {
                if (!CheckLoadConfig(hProc, buf, (DWORD)lpme->modBaseAddr, isSafeSEH, isStackCookie))
                {
                    safeSEHUnknown++;
                }
                if (!isSafeSEH)
                {
                    safeSEHMissing++;
                }
                if (!isStackCookie)
                {
                    stackCookieMissing++;
                }
            }
            else
            {
                safeSEHUnknown++;
            }
            while (Module32Next(hSnapshot, lpme))
            {
                nModules++;
                if (ReadProcessMemory(hProc, lpme->modBaseAddr, buf, 0x1000, &read))
                {
                    if (!CheckLoadConfig(hProc, buf, (DWORD)lpme->modBaseAddr, isSafeSEH, isStackCookie))
                    {
                        safeSEHUnknown++;
                    }
                    if (!isSafeSEH)
                    {
                        safeSEHMissing++;
                    }
                    if (!isStackCookie)
                    {
                        stackCookieMissing++;
                    }
                }
                else
                {
                    safeSEHUnknown++;
                }
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    CloseHandle(hSnapshot);
    delete lpme;
    return true;
}