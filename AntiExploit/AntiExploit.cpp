// AntiExploit.cpp : Defines the entry point for the application.

#include "framework.h"
#include "AntiExploit.h"
#include <commctrl.h>
#pragma comment(lib, "comctl32.lib")
#include <string>
#include <vector>
#include <sstream>
#include <shellapi.h>
#include <cstdlib>
#include "utils.h"
#include "structs.h"
#include <psapi.h>
#include <algorithm>

#define MAX_LOADSTRING 100
#define ANTIEXPLOIT_INJECT_ACTION_ID 0x1
#define ANTIEXPLOIT_DISABLE_ACTION_ID 0x2

// Global Variables:

int currentProcSelectedInList = 0;
HMENU rMenu;
HIMAGELIST himl;
DWORD nProcess = 0;
DWORD pidForAntiExploitSelected = 0;
HINSTANCE hInst;  
HWND hWndListView;
HWND mainWindow;
WCHAR szTitle[MAX_LOADSTRING];              
WCHAR szWindowClass[MAX_LOADSTRING];           
ATOM                MyRegisterClass(HINSTANCE hInstance);
HWND                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
HWND CreateListView(HWND hwndParent);
void ListInsertItem(int nItem);
BOOL InsertListViewItems(HWND hWndListView, int cItems, std::vector<PROCESS_INFO>);
std::vector <PROCESS_INFO> oldProcessList;

std::vector<PROCESS_INFO> UpdateProcessList();

bool cmpProc(const PROCESS_INFO& a, const PROCESS_INFO& b)
{
    return a.pid < b.pid;
}

bool pred(const PROCESS_INFO& a, const PROCESS_INFO& b) 
{
    if (a.pid == b.pid)
    {
        return true;
    }
    return false;
}

void Timerproc(
    HWND unnamedParam1,
    UINT unnamedParam2,
    UINT_PTR unnamedParam3,
    DWORD unnamedParam4
)
{
    std::vector<PROCESS_INFO> processesData = UpdateProcessList();

    bool ok = std::equal(std::begin(processesData), std::end(processesData),
        std::begin(oldProcessList), std::end(oldProcessList),
        [](const PROCESS_INFO& w1, const PROCESS_INFO& w2)
        {
            bool a = wcscmp(w1.processName.c_str(), w2.processName.c_str());
            return !a;
        });

    if (ok)
    {
        return;
    }
    
    std::sort(processesData.begin(), processesData.end(), cmpProc);
    std::sort(oldProcessList.begin(), oldProcessList.end(), cmpProc);

    std::vector<PROCESS_INFO> difference;
    std::set_difference(
        oldProcessList.begin(), oldProcessList.end(),
        processesData.begin(), processesData.end(),
        std::back_inserter(difference), cmpProc
    );

    /*
    
    std::set_intersection(
   installed_packages.begin(), installed_packages.end(),
   required_packages.begin(), installed_packages.end(),
   std::back_inserter(met_requirements));
    
    */

    //InsertListViewItems(hWndListView, processesData.size(), processesData);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    // Initialize global strings
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_ANTIEXPLOIT, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    mainWindow = InitInstance(hInstance, nCmdShow);
    if (!mainWindow)
    {
        return FALSE;
    }

    himl = ImageList_Create(16, 16, ILC_COLOR32, 3, 0);

    hWndListView = CreateListView(mainWindow);
    if (!hWndListView)
    {
        return FALSE;
    }

    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_ANTIEXPLOIT));

    MSG msg;

    //SetTimer(mainWindow, NULL, 3000, (TIMERPROC) Timerproc);

    // Main message loop:
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return (int) msg.wParam;
}
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex{};

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_ANTIEXPLOIT);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = NULL;

    return RegisterClassExW(&wcex);
}
HANDLE inject_DLL(const wchar_t* file_name, int PID)
{
    HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);                   //retrieving a handle to the target process

    wchar_t fullDLLPath[_MAX_PATH];                                                      //getting the full path of the dll file
    //GetModuleFileNameExW(GetCurrentProcess(), NULL, fullDLLPath, _MAX_PATH);

    GetFullPathNameW(file_name, _MAX_PATH, fullDLLPath, NULL);

    LPVOID DLLPath_addr = VirtualAllocEx(h_process, NULL, _MAX_PATH * sizeof (wchar_t),
        MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);                  //allocating memory in the target process
    WriteProcessMemory(h_process, DLLPath_addr, fullDLLPath,
        wcslen(fullDLLPath) * sizeof (wchar_t) + 2, NULL);                                    //writing the dll path into that memory

    LPVOID LoadLib_addr = GetProcAddress(GetModuleHandle(L"Kernel32"),                 //getting LoadLibraryA address (same across
        "LoadLibraryW");                             //  all processes) to start execution at it

    HANDLE h_rThread = CreateRemoteThread(h_process, NULL, 0,                         //starting a remote execution thread at LoadLibraryA
        (LPTHREAD_START_ROUTINE)LoadLib_addr, DLLPath_addr, 0, NULL);  //  and passing the dll path as an argument

    WaitForSingleObject(h_rThread, INFINITE);                                         //waiting for it to be finished

    DWORD exit_code;
    GetExitCodeThread(h_rThread, &exit_code);                                         //retrieving the return value, i.e., the module
                                                                                      //  handle returned by LoadLibraryA
    CloseHandle(h_rThread);                                                           //freeing the injected thread handle,
    VirtualFreeEx(h_process, DLLPath_addr, 0, MEM_RELEASE);                           //... and the memory allocated for the DLL path,
    CloseHandle(h_process);                                                           //... and the handle for the target process

    return (HANDLE)exit_code;
}
HANDLE detach_DLL(HMODULE hLibModule, int PID)
{
    HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);               

    LPVOID LoadLib_addr = GetProcAddress(GetModuleHandle(L"Kernel32"),                 
        "FreeLibrary");                           

    HANDLE h_rThread = CreateRemoteThread(h_process, NULL, 0,                       
        (LPTHREAD_START_ROUTINE)LoadLib_addr, hLibModule, 0, NULL);

    WaitForSingleObject(h_rThread, INFINITE);                                        
    DWORD exit_code;
    GetExitCodeThread(h_rThread, &exit_code);                                                                                           
    CloseHandle(h_rThread);                                                   
    CloseHandle(h_process);                                                         
    return (HANDLE)exit_code;
}

BOOL InjectAntiExploitCore(ULONG pid)
{
    SYSTEM_INFO inf{};
    GetNativeSystemInfo(&inf);
    if (inf.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
    {
        if (inject_DLL(L"AntiExploitCore.dll", pid))
        {
            return true;
        }
    }
    else if (inf.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
    {
        BOOL isWow64{};
        HANDLE p = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);
        if (p)
        {
            if (IsWow64Process(p, &isWow64))
            {
                if (isWow64)
                {
                    if (inject_DLL(L"AntiExploitCore.dll", pid))
                    {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
BOOL DetachAntiExploitCore(ULONG pid)
{
    LPMODULEENTRY32W lpme = new MODULEENTRY32W;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if (!hSnapshot)
    {
        return false;
    }
    lpme->dwSize = sizeof(MODULEENTRY32W);

    BYTE buf[0x1000]{};
    SIZE_T read{};

    if (Module32First(hSnapshot, lpme))
    {
        if (!wcscmp(lpme->szModule, L"AntiExploitCore.dll"))
        {
            if (!detach_DLL((HMODULE) lpme->modBaseAddr, pid))
            {
                return false;
            }
            return true;
        }
        while (Module32Next(hSnapshot, lpme))
        {
            if (!wcscmp(lpme->szModule, L"AntiExploitCore.dll"))
            {
                if (!detach_DLL((HMODULE)lpme->modBaseAddr, pid))
                {
                    return false;
                }
                return true;
            }
        }
    }
    DWORD a = GetLastError();
    CloseHandle(hSnapshot);
    delete lpme;
    return false;
}
void AddStockIcon()
{
    SHSTOCKICONINFO psii{};
    psii.cbSize = sizeof(psii);
    if (SHGetStockIconInfo(SIID_APPLICATION, SHGSI_ICON | SHGSI_SMALLICON, &psii) == S_OK)
    {
        HICON exeIcon = psii.hIcon;
        ICONINFO iconinfo;
        GetIconInfo(exeIcon, &iconinfo);
        HBITMAP hBitmap = iconinfo.hbmColor;
        ImageList_Add(himl, hBitmap, (HBITMAP)NULL);
        DestroyIcon(exeIcon);
    }
}
void AddIcon(LPWSTR pathBuf, DWORD processId)
{
    DWORD pathBufArg = MAX_PATH;
    HANDLE hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processId);
    if (hProc)
    {
        if (QueryFullProcessImageNameW(hProc, 0, pathBuf, &pathBufArg))
        {
            UINT nIcon = ExtractIconExW(pathBuf, -1, NULL, NULL, 1);
            if (nIcon)
            {
                HICON large;
                HICON small;
                if (ExtractIconExW(pathBuf, 0, &large, &small, 1))
                { 
                    // HICON icon = ExtractAssociatedIconEx(hInst, pathBuf, &a, &b);
                    if (small)
                    {
                        ICONINFO iconinfo;
                        GetIconInfo(small, &iconinfo);
                        HBITMAP hBitmap = iconinfo.hbmColor;
                        ImageList_Add(himl, hBitmap, (HBITMAP)NULL);
                        DestroyIcon(small);
                    }
                }
            }
            else
            {
                AddStockIcon();
            }
        }
        else
        {
            AddStockIcon();
        }
    }
    else
    {
        AddStockIcon();
    }
}
std::vector<PROCESS_INFO> UpdateProcessList()
{
    std::vector <PROCESS_INFO> procData;
    LPPROCESSENTRY32W currentProc = new PROCESSENTRY32W;
    currentProc->dwSize = sizeof(PROCESSENTRY32W);
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    std::wstringstream safeSEHFormat;
    std::wstringstream stackCookieFormat;

    if (Process32First(hSnapshot, currentProc))
    {
        std::wstring pid = std::to_wstring(currentProc->th32ProcessID);
        ULONG aslr = 0;
        LONG statusASLR = CheckASLR(currentProc->th32ProcessID, aslr);

        ULONG depStatus = 0;
        LONG statusDEP =  CheckDEP(currentProc->th32ProcessID, depStatus);

        if (statusASLR != 0)
            aslr = -1;
        if (statusDEP == STATUS_ACCESS_DENIED)
            depStatus = -1;

        ULONG safeSEHMissing = 0;
        ULONG safeSEHUnknown = 0;
        ULONG stackCookieMissing = 0;
        ULONG stackCookieUnknown = 0;
        ULONG nModules = 0;

        AddIcon(currentProc->szExeFile, currentProc->th32ProcessID);

        std::wstring processPath = std::wstring(currentProc->szExeFile);
        std::wstring processName = processPath.substr(processPath.find_last_of(L"/\\") + 1);

        if (CheckSafeSEHStackCanary(currentProc->th32ProcessID, safeSEHMissing, safeSEHUnknown, stackCookieMissing, stackCookieUnknown, nModules))
        {
            if (safeSEHUnknown > 0)
            {
                safeSEHFormat << safeSEHMissing << " (?" << safeSEHUnknown << ")";
            }
            else
            {
                safeSEHFormat << safeSEHMissing;
            }
            if (stackCookieUnknown > 0)
            {
                stackCookieFormat << stackCookieMissing << " (?" << stackCookieUnknown << ")";
            }
            else
            {
                stackCookieFormat << stackCookieMissing;
            }
            procData.push_back({ currentProc->th32ProcessID, processName, aslr, depStatus, nModules, safeSEHFormat.str(), stackCookieFormat.str(), false});
        }
        else
        {
            procData.push_back({ currentProc->th32ProcessID, processName, aslr, depStatus, 0, L"", L"", false});
        }

        // clear stringstream buf
        safeSEHFormat.str(std::wstring());
        stackCookieFormat.str(std::wstring());

        DWORD procIter = 0;
        while (Process32Next(hSnapshot, currentProc))
        {
            processPath = std::wstring(currentProc->szExeFile);
            processName = processPath.substr(processPath.find_last_of(L"/\\") + 1);
            AddIcon(currentProc->szExeFile, currentProc->th32ProcessID);

            pid = std::to_wstring(currentProc->th32ProcessID);

            statusASLR = CheckASLR(currentProc->th32ProcessID, aslr);
            statusDEP = CheckDEP(currentProc->th32ProcessID, depStatus);
            if (statusASLR == STATUS_ACCESS_DENIED)
                aslr = -1;
            if (statusDEP == STATUS_ACCESS_DENIED)
                depStatus = -1;

            if (CheckSafeSEHStackCanary(currentProc->th32ProcessID, safeSEHMissing, safeSEHUnknown, stackCookieMissing, stackCookieUnknown, nModules))
            {
                if (safeSEHUnknown > 0)
                {
                    safeSEHFormat << safeSEHMissing << " (?" << safeSEHUnknown << ")";
                }
                else
                {
                    safeSEHFormat << safeSEHMissing;
                }
                if (stackCookieUnknown > 0)
                {
                    stackCookieFormat << stackCookieMissing << " (?" << stackCookieUnknown << ")";
                }
                else
                {
                    stackCookieFormat << stackCookieMissing;
                }
                procData.push_back({ currentProc->th32ProcessID, processName, aslr, depStatus, nModules, safeSEHFormat.str(), stackCookieFormat.str(), false});
            }
            else
            {
                procData.push_back({ currentProc->th32ProcessID, processName, aslr, depStatus, 0, L"", L"", false});
            }

            // clear stringstream buf
            safeSEHFormat.str(std::wstring());
            stackCookieFormat.str(std::wstring());

            procIter++;
        }
        nProcess = procIter;
    }
    CloseHandle(hSnapshot);
    delete currentProc;
    oldProcessList = procData;
    return procData;
}
HWND CreateListView(HWND hwndParent)
{
    INITCOMMONCONTROLSEX icex{};           // Structure for control initialization.
    icex.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&icex);

    RECT rcClient;                       // The parent window's client area.

    GetClientRect(hwndParent, &rcClient);

    // Create the list-view window in report view with label editing enabled.
    HWND hWndListView = CreateWindow(WC_LISTVIEW,
        L"",
        WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_EDITLABELS,
        0, 0,
        rcClient.right - rcClient.left,
        rcClient.bottom - rcClient.top,
        hwndParent,
        (HMENU)IDC_ANTIEXPLOIT,
        hInst,
        NULL);

    SendMessage(hWndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    LVCOLUMN lvc {};
    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.iSubItem = 0;
    lvc.cx = 300;
    LPCWSTR proces = L"Nazwa Procesu";
    lvc.pszText = (LPWSTR)proces;
    ListView_InsertColumn(hWndListView, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.cx = 80;
    LPCWSTR pid = L"PID";
    lvc.pszText = (LPWSTR) pid;
    ListView_InsertColumn(hWndListView, 1, &lvc);

    lvc.iSubItem = 2;
    lvc.cx = 80;
    LPCWSTR aslr = L"ASLR";
    lvc.pszText = (LPWSTR) aslr;
    ListView_InsertColumn(hWndListView, 2, &lvc);

    lvc.iSubItem = 3;
    lvc.cx = 160;
    LPCWSTR dep = L"DEP";
    lvc.pszText = (LPWSTR)dep;
    ListView_InsertColumn(hWndListView, 3, &lvc);

    lvc.iSubItem = 4;
    lvc.cx = 100;
    LPCWSTR modules = L"Ilość modułów";
    lvc.pszText = (LPWSTR)modules;
    ListView_InsertColumn(hWndListView, 4, &lvc);

    lvc.iSubItem = 5;
    lvc.cx = 130;
    LPCWSTR nosafeseh = L"Moduły bez SafeSEH";
    lvc.pszText = (LPWSTR)nosafeseh;
    ListView_InsertColumn(hWndListView, 5, &lvc);

    lvc.iSubItem = 6;
    lvc.cx = 150;
    LPCWSTR stackcanary = L"Moduły bez Stack Canary";
    lvc.pszText = (LPWSTR)stackcanary;
    ListView_InsertColumn(hWndListView, 6, &lvc);

    lvc.iSubItem = 7;
    lvc.cx = 100;
    LPCWSTR antiexploit = L"AntiExploit";
    lvc.pszText = (LPWSTR)antiexploit;
    ListView_InsertColumn(hWndListView, 7, &lvc);

    std::vector<PROCESS_INFO> procData = UpdateProcessList();
    InsertListViewItems(hWndListView, procData.size(), procData);

    return (hWndListView);
}

// SetView: Sets a list-view's window style to change the view.
// hWndListView: A handle to the list-view control. 
// dwView:       A value specifying the new view style.
//
VOID SetView(HWND hWndListView, DWORD dwView)
{
    // Retrieve the current window style. 
    DWORD dwStyle = GetWindowLong(hWndListView, GWL_STYLE);

    // Set the window style only if the view bits changed.
    if ((dwStyle & LVS_TYPEMASK) != dwView)
    {
        SetWindowLong(hWndListView,
            GWL_STYLE,
            (dwStyle & ~LVS_TYPEMASK) | dwView);
    }               // Logical OR'ing of dwView with the result of 
}                   // a bitwise AND between dwStyle and 
                    // the Unary complenent of LVS_TYPEMASK.


BOOL InsertListViewItems(HWND hWndListView, int cItems, std::vector<PROCESS_INFO> procsInfo)
{
    LVITEM lvI{};

    // Initialize LVITEM members that are common to all items.
     // Sends an LVN_GETDISPINFO message.
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.state = 0;

    ListView_SetImageList(hWndListView, himl, LVSIL_SMALL);

    // Initialize LVITEM members that are different for each item.
    int index = 0;
    for (PROCESS_INFO  procInfo : procsInfo)
    {
        std::wstring pidStr = std::to_wstring(procInfo.pid);
        lvI.pszText = (LPWSTR)procInfo.processName.c_str() ;
        lvI.iItem = index;
        lvI.iImage = index;

        // Insert items into the list.
        if (ListView_InsertItem(hWndListView, &lvI) == -1)
            return FALSE;

        ListView_SetItemText(hWndListView, index, 1, (LPWSTR) pidStr.c_str());
        if (procInfo.aslr == 1)
        {
            ListView_SetItemText(hWndListView, index, 2, (LPWSTR) L"Aktywny");
        }
        else if (procInfo.aslr == -1)
        {
            ListView_SetItemText(hWndListView, index, 2, (LPWSTR) L"");
        }
        else if (procInfo.aslr == 0)
        {
            ListView_SetItemText(hWndListView, index, 2, (LPWSTR)L"Nieaktywny");
        }
        switch (procInfo.dep)
        {
            case -1:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"");
                break;
            }
            case 0:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"Nieaktywny");
                break;
            }
            case 1:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"Aktywny");
                break;
            }
            case 3:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"Aktywny (bez emulacji ATL)");
                break;
            }
            case 5:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"Aktywny Permanentnie");
                break;
            }
            case 7:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"Aktywny Permanentnie");
                break;
            }
            default:
            {
                ListView_SetItemText(hWndListView, index, 3, (LPWSTR)L"");
            }
        }
        if (procInfo.modules == 0)
        {
            ListView_SetItemText(hWndListView, index, 4, (LPWSTR)L"");
            ListView_SetItemText(hWndListView, index, 5, (LPWSTR)L"");
            ListView_SetItemText(hWndListView, index, 6, (LPWSTR)L"");
            ListView_SetItemText(hWndListView, index, 7, (LPWSTR)L"Nieaktywny");
        }
        else
        {
            std::wstring nModulesStr = std::to_wstring(procInfo.modules);
            ListView_SetItemText(hWndListView, index, 4, (LPWSTR) nModulesStr.c_str());
            ListView_SetItemText(hWndListView, index, 5, (LPWSTR) procInfo.safeSEH.c_str());
            ListView_SetItemText(hWndListView, index, 6, (LPWSTR) procInfo.stackCanary.c_str());
            ListView_SetItemText(hWndListView, index, 7, (LPWSTR)L"Nieaktywny");
        }
        index++;
    }
    return TRUE;
}
HWND InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance;

   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME,
      CW_USEDEFAULT, 0, 1140 , 800 , nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return NULL;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return hWnd;
}
int CALLBACK myCompFuncEx (LPARAM lp1, LPARAM lp2, LPARAM sortParam)
{
    t_data* data = (t_data*)sortParam;
    wchar_t buf1[100], buf2[100];
    ListView_GetItemText(data->hlist, lp1, data->iSubItem, buf1, _countof(buf1)-1);
    ListView_GetItemText(data->hlist, lp2, data->iSubItem, buf2, _countof(buf2)-1);
    buf1[99] = 0;
    buf2[99] = 0;
    INT buf1Int = _wtoi(buf1);
    INT buf2Int = _wtoi(buf2);
    int res = wcscmp(buf1, buf2);
    if ((!buf1Int) && (!buf2Int))
    {
        _wcslwr_s(buf1);
        _wcslwr_s(buf2);
        int res = wcscmp(buf1, buf2);
        return data->bSortAscending ? res >= 0 : res <= 0;
    }
    return data->bSortAscending ? buf1Int > buf2Int : buf1Int < buf2Int;
}
void OnColumnClickEx(LPNMLISTVIEW pLVInfo)
{
    static int nSortColumn = 0;
    static BOOL bSortAscending = TRUE;
    if (pLVInfo->iSubItem != nSortColumn)
        bSortAscending = TRUE;
    else
        bSortAscending = !bSortAscending;
    nSortColumn = pLVInfo->iSubItem;

    t_data data;
    data.hlist = pLVInfo->hdr.hwndFrom;
    data.iSubItem = nSortColumn;
    data.bSortAscending = bSortAscending;
    ListView_SortItemsEx(pLVInfo->hdr.hwndFrom, myCompFuncEx, &data);
}
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
        {
            break;
        }
        case WM_CREATE:
        {
            break;
        }
        case WM_NOTIFY:
        {
            LPNMHDR lpnmh = (LPNMHDR)lParam;
            if (lpnmh->code == LVN_COLUMNCLICK)
            {
                NMLISTVIEW* pListView = (NMLISTVIEW*)lParam;
                OnColumnClickEx(pListView);
            }
            else if (lpnmh->code == NM_RCLICK)
            {
                LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE)lParam;

                WCHAR pidStr[20];

                ListView_GetItemText(hWndListView, lpnmitem->iItem, 1, pidStr, 20);

                currentProcSelectedInList = lpnmitem->iItem;

                pidForAntiExploitSelected = _wtoi(pidStr);
                if (pidForAntiExploitSelected)
                {
                    POINT cursor;
                    GetCursorPos(&cursor);

                    rMenu = CreatePopupMenu();
                    AppendMenuW(rMenu, MF_STRING, ANTIEXPLOIT_INJECT_ACTION_ID, L"Załaduj AntiExploit");
                    AppendMenuW(rMenu, MF_STRING, ANTIEXPLOIT_DISABLE_ACTION_ID, L"Wyłącz AntiExploit");
                    TrackPopupMenu(rMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, cursor.x, cursor.y, 0, hWnd, NULL);
                }
            }
            break;
        }
        case WM_GETMINMAXINFO:
        {
            LPMINMAXINFO lpMMI = (LPMINMAXINFO)lParam;
            lpMMI->ptMinTrackSize.x = 600;
            lpMMI->ptMinTrackSize.y = 300;
            break;
        }
        case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            switch (wmId)
            {
            case IDM_ABOUT:
            {
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            }
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            case ANTIEXPLOIT_INJECT_ACTION_ID:
            {
                if (InjectAntiExploitCore(pidForAntiExploitSelected))
                {
                    LPCWSTR aktywny = L"Aktywny";
                    MessageBoxW(mainWindow, L"Pomyślnie wczytano rozszerzenie AntiExploit", L"Komunikat załadowania AntiExploit", 0);
                    ListView_SetItemText(hWndListView, currentProcSelectedInList, 7, (LPWSTR)aktywny);
                }
                else
                {
                    MessageBoxW(mainWindow, L"Nie udało się załadować rozszerzenia AntiExploit", L"Komunikat załadowania AntiExploit", 0);
                }
                DestroyMenu(rMenu);
                break;
            }
            case ANTIEXPLOIT_DISABLE_ACTION_ID:
            {
                if (DetachAntiExploitCore(pidForAntiExploitSelected))
                {
                    LPCWSTR nieaktywny = L"Nieaktywny";
                    MessageBoxW(mainWindow, L"Pomyślnie usunięto rozszerzenie AntiExploit", L"Komunikat usunięcia AntiExploit", 0);
                    ListView_SetItemText(hWndListView, currentProcSelectedInList, 7, (LPWSTR)nieaktywny);
                }
                else
                {
                    MessageBoxW(mainWindow, L"Nie udało się usunąć rozszerzenia AntiExploit", L"Komunikat usunięcia AntiExploit", 0);
                }
                DestroyMenu(rMenu);
                break;
            }
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: Add any drawing code that uses hdc here...
            EndPaint(hWnd, &ps);
        }
        break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}
